# Role-Based Execution

**Author:** Kevin Gilbert  
**Version:** 1.0  
**Purpose:** Establish a stable, modular method of distributing cognitive workload across defined execution roles for multi-model AI collaboration.

---

## Overview

Role-Based Execution is the foundation of the Ironbound Frameworks.  
Every task is executed inside a **single, clearly defined role** that dictates what the model may and may not do.

This prevents drift, eliminates ambiguity, and enforces stable output across multi-step workflows.

---

## The Four Roles

### **1. Architect**
- Designs structure and high-level solution
- Defines constraints and scope
- Avoids polishing or rewriting prose
- Focuses on clarity, not aesthetics

### **2. Editor**
- Refines structure created by the Architect
- Improves clarity without expanding scope
- Preserves all constraints
- Avoids adding new ideas

### **3. Stress Tester**
- Attempts to break or expose weaknesses
- Probes edge cases, contradictions, and failures
- Never rewrites, only evaluates
- Reports vulnerabilities without proposing solutions

### **4. Polisher**
- Produces the final clean version
- Repairs grammar, cadence, flow
- Does not introduce new content
- Respects role boundaries, constraints, and structure

---

## Why It Matters

Role separation prevents LLMs from blending creative, analytical, and evaluative tasksâ€”  
the root cause of **Role Drift**, which destabilizes output.

Clear role boundaries enable:
- Stable multi-model orchestration  
- Consistent document production  
- Accurate self-correction  
- Drift-resistant collaboration  

---

## Summary

Role-Based Execution ensures that each step of a workflow is handled by a **single, purpose-built cognitive mode**, reducing drift and producing predictable, professional-quality outputs.